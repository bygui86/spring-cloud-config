
---[ Encryption and Decryption

Requirement: To use cryptographically strong keys together with Spring encryption and decryption features we need the ‘Java Cryptography Extension (JCE) 
Unlimited Strength Jurisdiction Policy Files’ installed in our JVM. These can be downloaded for example from Oracle. To install follow the instructions 
included in the download. Some Linux distributions also provide an installable package through their package managers.

Since the config server is supporting encryption and decryption of property values, we can use public repositories as storage for sensitive data like 
usernames and passwords. Encrypted values are prefixed with the string {cipher} and can be generated by an REST-call to the path ‘/encrypt’, if the server 
is configured to use a symmetric key or a key pair.

An endpoint to decrypt is also available. Both endpoints accept a path containing placeholders for the name of the application and its current profile: 
‘/*/{name}/{profile}’. This is especially useful for controlling cryptography per client. However, before they become useful, we have to configure a 
cryptographic key which we will do in the next section.

*** Tip: 
	If we use curl to call the en-/decryption API, it’s better to use the –data-urlencode option (instead of –data/-d), or set the ‘Content-Type’ 
	header explicit to ‘text/plain’. This ensures a correct handling of special characters like ‘+’ in the encrypted values.

If a value can’t be decrypted automatically while fetching through the client, its key is renamed with the name itself, prefixed by the word ‘invalid’. 
This should prevent, for example the usage of an encrypted value as password.

*** Tip: 
	When setting-up a repository containing YAML files, we have to surround our encrypted and prefixed values with single-quotes! With Properties this 
	is not the case.



---[ Key Management

The config server is per default enabled to encrypt property values in a symmetric or asymmetric way.

-[ Symmetric cryptography
	Simply set the property ‘encrypt.key’ in our application.properties to a secret of our choice. Alternatively we can pass-in the environment variable 
	ENCRYPT_KEY.

-[ Asymmetric cryptography
	We can set ‘encrypt.key’ to a PEM-encoded string value or configure a keystore to use.

Because we need a highly secured environment for our demo server, we chose the latter option and generating a new keystore, including a RSA key-pair, 
with the Java keytool first:
	$ keytool -genkeypair -alias rs-spring-cloudconfig-server-key \
		-keyalg RSA -keysize 4096 -sigalg SHA512withRSA \
		-dname "CN=rS-SpringCloudConfig,OU=RabbitHole Cloud,O=RabbitHole,C=CH" \
		-keypass rS-s42-s3cr3t -keystore rs-spring-cloudconfig-server.jks \
		-storepass rS-s42-s70r3-s3cr3t

*** -dname (Subject Name) property quick explanation:
	The name of the entity whose public key the certificate identifies. This name uses the X.500 standard, so it is intended to be unique across the Internet. 
	This is the X.500 Distinguished Name (DN) of the entity, for example,
		CN=Java Duke, OU=Java Software Division, O=Oracle Corporation, C=US
	These refer to the subject's Common Name, Organizational Unit, Organization, and Country.

*** Tip: 
	To better understand the usage of this command, see http://docs.oracle.com/javase/7/docs/technotes/tools/solaris/keytool.html

Copy the generated file "rs-spring-cloudconfig-server.jks" to the project resources folder "{proj-resources}/security/"

After that, we’re adding the created keystore to our server’s application.properties and re-run it:
	### ENCRYPTION
	# keytool-alias
	encrypt.key-store.alias=rs-spring-cloudconfig-server-key
	# keytool-file location
	encrypt.key-store.location=classpath:/security/rs-spring-cloudconfig-server.jks
	# keytool-keypass
	encrypt.key-store.secret=rS-s42-s3cr3t
	# keytool-storepass
	encrypt.key-store.password=rS-s42-s70r3-s3cr3t
